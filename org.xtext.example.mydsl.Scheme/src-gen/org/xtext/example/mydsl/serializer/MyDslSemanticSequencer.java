/*
 * generated by Xtext 2.16.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.scheme.Application;
import org.xtext.example.mydsl.scheme.Body;
import org.xtext.example.mydsl.scheme.Comparison;
import org.xtext.example.mydsl.scheme.Conditional;
import org.xtext.example.mydsl.scheme.Definition;
import org.xtext.example.mydsl.scheme.Expression;
import org.xtext.example.mydsl.scheme.Form;
import org.xtext.example.mydsl.scheme.IDscheme;
import org.xtext.example.mydsl.scheme.Initial;
import org.xtext.example.mydsl.scheme.MultipleCondition;
import org.xtext.example.mydsl.scheme.Operation;
import org.xtext.example.mydsl.scheme.Program;
import org.xtext.example.mydsl.scheme.SchemePackage;
import org.xtext.example.mydsl.scheme.Subsequent;
import org.xtext.example.mydsl.scheme.VariableDefinition;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SchemePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SchemePackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case SchemePackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case SchemePackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case SchemePackage.CONDITIONAL:
				sequence_Conditional(context, (Conditional) semanticObject); 
				return; 
			case SchemePackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case SchemePackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case SchemePackage.FORM:
				sequence_Form(context, (Form) semanticObject); 
				return; 
			case SchemePackage.IDSCHEME:
				sequence_IDscheme(context, (IDscheme) semanticObject); 
				return; 
			case SchemePackage.INITIAL:
				sequence_Initial(context, (Initial) semanticObject); 
				return; 
			case SchemePackage.MULTIPLE_CONDITION:
				sequence_MultipleCondition(context, (MultipleCondition) semanticObject); 
				return; 
			case SchemePackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case SchemePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case SchemePackage.SET:
				sequence_Set(context, (org.xtext.example.mydsl.scheme.Set) semanticObject); 
				return; 
			case SchemePackage.SUBSEQUENT:
				sequence_Subsequent(context, (Subsequent) semanticObject); 
				return; 
			case SchemePackage.VARIABLE_DEFINITION:
				sequence_VariableDefinition(context, (VariableDefinition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (expression=Expression expressions+=Expression*)
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Body returns Body
	 *
	 * Constraint:
	 *     (definition+=Definition* expression+=Expression+)
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Comparison returns Comparison
	 *
	 * Constraint:
	 *     (num1=NUMBER num2=NUMBER)?
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conditional returns Conditional
	 *
	 * Constraint:
	 *     (condition=Comparison iftrue=Expression else=Expression?)
	 */
	protected void sequence_Conditional(ISerializationContext context, Conditional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     variableDefinition=VariableDefinition
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SchemePackage.Literals.DEFINITION__VARIABLE_DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchemePackage.Literals.DEFINITION__VARIABLE_DEFINITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefinitionAccess().getVariableDefinitionVariableDefinitionParserRuleCall_0(), semanticObject.getVariableDefinition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *
	 * Constraint:
	 *     (
	 *         constant=Constant | 
	 *         oper=Operation | 
	 *         cond=Conditional | 
	 *         set=Set | 
	 *         app=Application | 
	 *         mult=MultipleCondition
	 *     )
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Form returns Form
	 *
	 * Constraint:
	 *     (definition+=Definition | expression+=Expression)
	 */
	protected void sequence_Form(ISerializationContext context, Form semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IDscheme returns IDscheme
	 *
	 * Constraint:
	 *     (init=Initial subs+=Subsequent*)
	 */
	protected void sequence_IDscheme(ISerializationContext context, IDscheme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initial returns Initial
	 *
	 * Constraint:
	 *     (
	 *         init=LETTER | 
	 *         init='!' | 
	 *         init='$' | 
	 *         init='%' | 
	 *         init='&' | 
	 *         init='*' | 
	 *         init='/' | 
	 *         init=':' | 
	 *         init='<' | 
	 *         init='=' | 
	 *         init='>' | 
	 *         init='?' | 
	 *         init='~' | 
	 *         init='_' | 
	 *         init='^'
	 *     )
	 */
	protected void sequence_Initial(ISerializationContext context, Initial semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultipleCondition returns MultipleCondition
	 *
	 * Constraint:
	 *     (comp+=Comparison exp+=Expression expression=Expression?)
	 */
	protected void sequence_MultipleCondition(ISerializationContext context, MultipleCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (operation='(' operator=OPER numb+=NUMBER* numb2+=NUMBER*)
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     program+=Form+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Set returns Set
	 *
	 * Constraint:
	 *     (cons=Constant expression=Expression)
	 */
	protected void sequence_Set(ISerializationContext context, org.xtext.example.mydsl.scheme.Set semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SchemePackage.Literals.SET__CONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchemePackage.Literals.SET__CONS));
			if (transientValues.isValueTransient(semanticObject, SchemePackage.Literals.SET__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SchemePackage.Literals.SET__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetAccess().getConsConstantParserRuleCall_2_0(), semanticObject.getCons());
		feeder.accept(grammarAccess.getSetAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Subsequent returns Subsequent
	 *
	 * Constraint:
	 *     init=Initial?
	 */
	protected void sequence_Subsequent(ISerializationContext context, Subsequent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDefinition returns VariableDefinition
	 *
	 * Constraint:
	 *     ((variable=ID expression=Expression) | (variable=ID variables+=ID* body=Body) | (variable=ID variables+=ID* var=ID body=Body))
	 */
	protected void sequence_VariableDefinition(ISerializationContext context, VariableDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
